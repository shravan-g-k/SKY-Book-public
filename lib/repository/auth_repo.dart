import 'dart:convert';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:journalbot/const.dart';
import 'package:journalbot/model/user_model.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepository();
});

// userFutureProvider for the AppUser object
// calls the getUser method in the AuthRepository
// updates the userProvider state
// Takes a String token as an argument
final userFutureProvider = FutureProvider.family((ref, String token) {
  return ref.read(authRepositoryProvider).getUser(token).then((value) {
    ref.read(userProvider.notifier).state = value;
    return value;
  }).catchError(
    (error) {
      throw error;
    },
  );
});

// StateProvider for the AppUser object
final userProvider = StateProvider<AppUser?>((ref) {
  return null;
});

// This is the repository class for the authentication
// Methods - signInWithGoogle, signOut, getUser
class AuthRepository {
  // Sign in with Google
  // Return AppUser object
  // No error handling - done in the controller
  Future<AppUser> signInWithGoogle() async {
    // Trigger the authentication flow
    final GoogleSignInAccount? googleUser = await GoogleSignIn().signIn();
    // Obtain the auth details from the request
    final GoogleSignInAuthentication? googleAuth =
        await googleUser?.authentication;
    // Create a new credential
    final credential = GoogleAuthProvider.credential(
      accessToken: googleAuth?.accessToken,
      idToken: googleAuth?.idToken,
    );
    // Sign in to Firebase with the Google [UserCredential]
    UserCredential user =
        await FirebaseAuth.instance.signInWithCredential(credential);
    // Uri of the server
    Uri url = Uri.parse('$serverAddress/signin');
    // Send a POST request to the server
    // with the user's name and email
    final response = await http.post(
      url,
      body: jsonEncode({
        'name': user.user?.displayName!,
        'email': user.user?.email!,
      }),
      headers: {'Content-Type': 'application/json; charset=UTF-8'},
    );
    // Decode the response
    Map<String, dynamic> json = jsonDecode(response.body);
    // Extract the Map user which contains the name,email,id(generated by the server)
    Map<String, dynamic> data = json['user'];
    // Add the token to the Map
    data.addAll({'token': json['token']});
    // Create an AppUser object from the Map
    AppUser appUser = AppUser.fromMap(data);
    // Save the token to the local storage
    SharedPreferences.getInstance().then((prefs) {
      prefs.setString(tokenKey, appUser.token);
    });
    return appUser;
  }

  // Sign out
  // No error handling - done in the controller
  Future<void> signOut() async {
    try {
      await FirebaseAuth.instance.signOut();
      await GoogleSignIn().signOut();
      SharedPreferences.getInstance().then((prefs) {
        prefs.remove(tokenKey);
      });
    } catch (e) {
      rethrow;
    }
  }

  // Get the AppUser object from the token
  // Return AppUser object
  // Doesnt relate with the controller
  // Used in the wrapper.dart - meant to call this only once when the app starts
  // Once user is fetched from the server, the userProvider state is updated(by the userFutureProvider)
  Future<AppUser> getUser(String token) async {
    final response = await http.get(Uri.parse('$serverAddress/user'),
        headers: {'x-auth-token': token});
    if (response.statusCode != 200) {
      throw Exception('Error fetching user');
    }
    Map<String, dynamic> json = jsonDecode(response.body);
    AppUser appUser = AppUser.fromMap({...json, 'token': token});
    return appUser;
  }
}
